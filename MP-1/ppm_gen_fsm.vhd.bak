-- library declaration
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;  
-- entity
entity ppm_gen is
port (CLK, gen_en : in std_logic;
	ppm_gen_resetn : in std_logic;
	inc_cycle_count : in std_logic_vector(31 downto 0);
	read_addr : out std_logic_vector(2 downto 0);
	ppm_output : out std_logic);
end ppm_gen;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;  

entity cycle_decrementer is 
port(resetn, clk, enable, load : in std_logic;
	start_val : in std_logic_vector (31 downto 0);
	count : out std_logic_vector (31 downto 0)
);
end cycle_decrementer;

architecture decrementer of cycle_decrementer is
signal sel: std_logic_vector(1 downto 0);
signal count_sig : std_logic_vector(31 downto 0);
begin
    process(clk, resetn, enable, load)
    begin
		sel <= resetn&enable;
		count <= count_sig;
		if(rising_edge(clk)) then
			if(load = '1') then count <= start_val;
			else
				case sel is
					when "00" | "01" =>
						--reset to clock cycles in gap
						count_sig <= x"FFFFFFFF";
					when "11" =>
						if(count_sig = x"00000000") then count_sig <= x"00000000";
						else count_sig <= std_logic_vector(unsigned(count_sig) - 1);
						end if;
					when "10" =>
						count_sig <= count_sig;
					when others =>
						count_sig <= x"00000000";
				end case;
			end if;
		end if;
    end process;
end decrementer;

-- architecture
architecture ppm_gen of ppm_gen is
	type state_type is (a, b, c);
	signal PS, NS : state_type;
	signal decrement_load, decrement_en, decrement_resetn, gen_resetn_sig : std_logic;
	signal addr_sig :  std_logic_vector(2 downto 0);
	signal decrement_out : std_logic_vector(31 downto 0);

	component cycle_decrementer
	port(resetn, clk, enable, load : in std_logic;
		start_val : in std_logic_vector (31 downto 0);
		count : out std_logic_vector (31 downto 0)
	);

	begin
	gen_resetn_sig <= ppm_gen_resetn;
	read_addr <= addr_sig;
    	current_count : cycle_decrementer port map(decrement_resetn, CLK, decrement_en, decrement_load, inc_cycle_count, decrement_out);
	
	sync_proc: process(CLK, NS, ppm_gen_resetn, gen_resetn_sig)
		begin
		--block should receive reset when channel is idle
		if (gen_resetn_sig = '0') then PS <= a;
		elsif (rising_edge(CLK)) then PS <= NS;
		end if;
	end process sync_proc;
	comb_proc: process(PS, gen_en)
		begin
		ppm_output <= '0';
		case PS is
			when a =>
				if (gen_en='0') then NS<=a; decrement_resetn <= '0'; decrement_en <= '0'; addr_sig <= "000";
				else decrement_resetn <= '1'; NS <= b; read_addr <= "001"; decrement_load <= '0';
				end if;
			when b =>
				ppm_output <= '1';
				decrement_load <= '0';
				if (decrement_out = x"00000000") then decrement_en <= '0'; decrement_resetn <= '0'; NS<=c;
				else decrement_en <= '1'; NS <= b;
				end if;
			when c =>
				ppm_output <= '0';
				if (decrement_out <= x"0000") then NS<=b; addr_sig <= std_logic_vector(unsigned(addr_sig) + 1);
				else decrement_en <= '1'; NS <= c;
				end if;
			when others =>
				ppm_output <= '1'; decrement_out <= x"00000000"; decrement_en <= '0'; decrement_resetn <= '0'; NS<=a;
		end case;
		if(addr_sig = "111") then gen_resetn_sig <= '0';
		end if;
	end process comb_proc;
end ppm_gen;
-- library declaration
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity state_reset_counter is 
port (inc, resetn, cnt_clk : in std_logic;
	channel_resetn, eof : out std_logic;
	count : out std_logic_vector (2 downto 0));
end state_reset_counter;

architecture reset_counter of state_reset_counter is
signal sel : std_logic_vector(1 downto 0);
signal count_sig : std_logic_vector(2 downto 0);
begin
    process(cnt_clk, resetn, inc)
    begin
	count <= count_sig;
	channel_resetn <= '1';
	sel <= resetn&inc;
	if(rising_edge(cnt_clk)) then
		eof <= '0';
		case sel is
			when "00" | "01" =>
				count_sig <= "000";
			when "11" =>
				count_sig <= std_logic_vector(unsigned(count_sig) + 1);
			when "10" =>
				channel_resetn <= '1';
			when others =>
				channel_resetn <= '0';
		end case;
	end if;
	if(count_sig = "111") then
		count_sig <= "000";
		channel_resetn <= '0';
		eof <= '1';
	else channel_resetn <= '1';
	end if;
    end process;
end reset_counter;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

-- entity
entity ppm_read is
port (ppm_input, CLK : in std_logic;
	ppm_read_reset : in std_logic;
	channel_count, count_enable : out std_logic;
	cycle_count : out std_logic_vector(31 downto 0);
	write_addr : out std_logic_vector(2 downto 0);
	end_of_frame : out std_logic);
end ppm_read;

-- architecture
architecture ppm_read of ppm_read is
	type state_type is (a, b, c);
	signal PS, NS : state_type;
	signal chan_reset_loop, count_en_sig, channel_count_sig : std_logic;
	signal cycle_count_sig : std_logic_vector(31 downto 0);

	component state_reset_counter
		port (inc, resetn, cnt_clk : in std_logic;
		channel_resetn, eof : out std_logic;
		count : out std_logic_vector (2 downto 0));
	end component;
	
	begin
	chan_reset_loop <= ppm_read_reset;
	count_enable <= count_en_sig;
	cycle_count <= cycle_count_sig;
	channel_count <= channel_count_sig;
	write_addr <= "000";
    	channel_tracker : state_reset_counter port map(channel_count_sig, chan_reset_loop, CLK, chan_reset_loop, end_of_frame, write_addr);
	
	sync_proc: process(CLK, NS, ppm_read_reset)
		begin
		if (chan_reset_loop = '0') then	PS <= a;
		elsif (rising_edge(CLK)) then PS <= NS;
		end if;
	end process sync_proc;
	comb_proc: process(PS, ppm_input)
		begin
		count_en_sig <= '0';
		case PS is
			when a =>
				count_en_sig <= '0';
				if (ppm_input='0') then NS<=b; channel_count_sig <= '0';
				else NS <= a; channel_count_sig <= '0';
				end if;
			when b =>
				count_en_sig <= '0'; 
				cycle_count_sig <= x"00000000";
				if (ppm_input='0') then NS<=b; channel_count_sig <= '0';
				else NS <= c; channel_count_sig <= '1';
				end if;
			when c =>
				cycle_count_sig <= std_logic_vector(unsigned(cycle_count_sig) + 1);
				count_en_sig <= '1';
				if (ppm_input='0') then NS<=b; channel_count_sig <= '0';
				else NS <= c;  channel_count_sig <= '0';
				end if;
			when others =>
				channel_count_sig <= '0'; count_en_sig <= '0'; NS<=a;
		end case;
	end process comb_proc;
end ppm_read;


